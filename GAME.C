#define DEBUGMODE

#include <stdio.h>
#include <string.h>
#include "allegro.h"
#include "engine.h"
#include "game.h"
#include "player.h"
#include "utils.h"
//game data resources
#include "data.h"
#include "ego.h"
//includes all rooms
#include "room01.h"
#include "room02.h"

int main()
{
    //initialization
    main_init();
    cursor_init();
    tick_init();

    //main game loop
    while (!key[KEY_ESC])
    {
        //general update
        clear(buffer);
        tick_update();
        //show_debug("X",mouse_x);
        //show_debug("Y",mouse_y);
        
        //check actual game state
        switch (game.state)
        {
            case TITLE_STATE:
                //placeholder test
                game_write("ADVENTURE GAME");
                cursor.enabled = true;
                cursor_update();
                cursor_draw();
                if (cursor.click)
                {
                    game_fade_out();
                    game_init();
                    cursor_init();
                    player_init();
                    game.state = PLAYING_STATE;
                }
                break;
            case PLAYING_STATE:
                //update
                game_update();
                msg_update();
                room[game.actualRoom].room_update();
                room_action_update();
                cursor_update();
                player_update();
                
                //draw
                room_draw();
                player_draw();
                room_front_draw();
                hud_draw();
                status_bar_draw();
                cursor_draw();
                msg_draw();

                break;
            case PAUSE_STATE:
                game_update();

                //draw
                room_draw();
                game_write("PAUSA");
                break;
        }
        //general draw
        debug_draw();

        //blits to screen
        blit(buffer, screen, 0, 0, 0, 0, buffer->w, buffer->h);
        //do pending fade in
        game_do_fade_in();
    }

    //quits the game
    game_exit();
    return EXIT_SUCCESS;
}

//general initialization
void main_init()
{
    //initialize and install modules
    allegro_init();
    if (install_timer() != 0)
        abort_on_error("Error iniciando el modulo timer");
    if (install_mouse() < 0)
        abort_on_error("Error iniciando el mouse");
    if (install_keyboard() != 0)
        abort_on_error("Error iniciando el teclado");
    if (install_sound(0, MIDI_AUTODETECT, 0) != 0)
        abort_on_error("Error iniciando el sonido");

    //set video mode
    set_color_depth(8);
    if (set_gfx_mode(GFX_AUTODETECT, RES_X, RES_Y, 0, 0) != 0)
        abort_on_error("Error seteando modo grafico");

     //screen buffer creation
    buffer = create_bitmap(RES_X, RES_Y);

    //load resources
    load_resources();

    //set game initial state
    game.state = TITLE_STATE;

    //clear flags
    game.fadeIn = 0;
}

//timer function callback
void incTick(void)
{
    //increment on 100ms
    tick++;;
}
END_OF_FUNCTION(incTick);

//function to load resources from dat file
void load_resources()
{
    //loads data file
    dataFile = load_datafile("data.dat");
    if (!dataFile)
        abort_on_error("Archivo data.dat invalido o inexistente");
    //loads player data file
    playerDataFile = load_datafile("ego.dat");
    if (!dataFile)
        abort_on_error("Archivo ego.dat invalido o inexistente");

    //sets and get the palette
    set_palette((RGB*)dataFile[dGamePal].dat);
    get_palette(gamePalette);

    //loads game resources
    hud.image               = (BITMAP *)dataFile[dHud].dat;
    hud.hsImage             = (BITMAP *)dataFile[dHudhs].dat;
    hud.verbSelImage[GO]    = (BITMAP *)dataFile[dHudGoSel].dat;
    hud.verbSelImage[TAKE]  = (BITMAP *)dataFile[dHudTakeSel].dat;
    hud.verbSelImage[MOVE]  = (BITMAP *)dataFile[dHudMoveSel].dat;
    hud.verbSelImage[LOOK]  = (BITMAP *)dataFile[dHudLookSel].dat;
    hud.verbSelImage[USE]   = (BITMAP *)dataFile[dHudUseSel].dat;
    hud.verbSelImage[GIVE]  = (BITMAP *)dataFile[dHudGiveSel].dat;
    hud.verbSelImage[OPEN]  = (BITMAP *)dataFile[dHudOpenSel].dat;
    hud.verbSelImage[CLOSE] = (BITMAP *)dataFile[dHudCloseSel].dat;
    hud.verbSelImage[TALK]  = (BITMAP *)dataFile[dHudTalkSel].dat;

    cursor.image       = (BITMAP *)dataFile[dCursor].dat;
    //loads room resources
    room[0].image      = (BITMAP *)dataFile[dRoom01].dat;
    room[0].hsImage    = (BITMAP *)dataFile[dRoom01hs].dat;
    room[0].wImage     = (BITMAP *)dataFile[dRoom01w].dat;
    room[0].fImage     = (BITMAP *)dataFile[dRoom01f].dat;
    room[0].song       = (MIDI *)dataFile[dSong01].dat;
    room[1].image      = (BITMAP *)dataFile[dRoom02].dat;
    room[1].hsImage    = (BITMAP *)dataFile[dRoom02hs].dat;
    room[1].song       = (MIDI *)dataFile[dSong01].dat;
    room[1].wImage     = (BITMAP *)dataFile[dRoom02w].dat;
    room[1].fImage     = (BITMAP *)dataFile[dRoom01f].dat;

    //room start positions
    room[0].start_pos_x = 170;
    room[0].start_pos_y = 100;
    room[1].start_pos_x = 179;
    room[1].start_pos_y = 117;
    
    //assign room function pointers
    room[0].room_get_object = &r01_get_object;
    room[0].room_get_default_object_verb = &r01_get_default_object_verb;
    room[0].room_init = &r01_room_init;
    room[0].room_update = &r01_room_update;

    room[1].room_get_object = &r02_get_object;
    room[1].room_get_default_object_verb = &r01_get_default_object_verb;
    room[1].room_update = &r02_room_update;
    room[1].room_init = &r02_room_init;

    //test player
    player.image[0]     = (BITMAP *)playerDataFile[dEgo01].dat;
    player.image[1]     = (BITMAP *)playerDataFile[dEgo02].dat;
    player.image[2]     = (BITMAP *)playerDataFile[dEgo03].dat;
    player.image[3]     = (BITMAP *)playerDataFile[dEgo04].dat;
    player.image[4]     = (BITMAP *)playerDataFile[dEgo05].dat;
    player.image[5]     = (BITMAP *)playerDataFile[dEgo06].dat;
    player.image[6]     = (BITMAP *)playerDataFile[dEgo07].dat;
    player.image[7]     = (BITMAP *)playerDataFile[dEgo08].dat;
    player.image[8]     = (BITMAP *)playerDataFile[dEgo09].dat;
    player.image[9]     = (BITMAP *)playerDataFile[dEgo10].dat;
    player.image[10]    = (BITMAP *)playerDataFile[dEgo11].dat;
    
}

//function to init game
void game_init()
{
    gameConfig.textSpeed = 10; //8 chars per second? This going to be on config
    gameConfig.playerSpeed = ftofix(0.3);
    
    //init game vars
    game.actualRoom = 0;
    game.lastRoom = -1;     //to force first room_init
    
    roomScript.active = 0;
    roomScript.object = 0;
    roomScript.verb = 0;
    roomScript.step = 0;
    roomScript.lastStep = 0;
    roomScript.stepTime = 0;

    //initialize x and y position of highlight verb images
    hud.posXVerbSelImage[GO]    = VERB_SEL_ROW_1_X;
    hud.posYVerbSelImage[GO]    = VERB_SEL_COL_1_Y;
    hud.posXVerbSelImage[TAKE]  = VERB_SEL_ROW_1_X;
    hud.posYVerbSelImage[TAKE]  = VERB_SEL_COL_2_Y;
    hud.posXVerbSelImage[MOVE]  = VERB_SEL_ROW_1_X;
    hud.posYVerbSelImage[MOVE]  = VERB_SEL_COL_3_Y;
    hud.posXVerbSelImage[LOOK]  = VERB_SEL_ROW_2_X;
    hud.posYVerbSelImage[LOOK]  = VERB_SEL_COL_1_Y;
    hud.posXVerbSelImage[USE]   = VERB_SEL_ROW_2_X;
    hud.posYVerbSelImage[USE]   = VERB_SEL_COL_2_Y;
    hud.posXVerbSelImage[GIVE]  = VERB_SEL_ROW_2_X;
    hud.posYVerbSelImage[GIVE]  = VERB_SEL_COL_3_Y;
    hud.posXVerbSelImage[OPEN]  = VERB_SEL_ROW_3_X;
    hud.posYVerbSelImage[OPEN]  = VERB_SEL_COL_1_Y;
    hud.posXVerbSelImage[CLOSE] = VERB_SEL_ROW_3_X;
    hud.posYVerbSelImage[CLOSE] = VERB_SEL_COL_2_Y;
    hud.posXVerbSelImage[TALK]  = VERB_SEL_ROW_3_X;
    hud.posYVerbSelImage[TALK]  = VERB_SEL_COL_3_Y;
    
    //call init game modules
    msg_init();
}

//game update function
void game_update()
{
    //pause handler
    if (key[KEY_SPACE])
    {
        if (!gameKeys.pausePressed)
        {
            game.state = game.state != PAUSE_STATE ? PAUSE_STATE : PLAYING_STATE;
            gameKeys.pausePressed = true;
        }
    }
    else
    {
        gameKeys.pausePressed = false;
    }

    check_room_changed();

    //debug
    show_debug("Moving", player.moving);
}

//function to write text on screen
void game_write(char *text)
{
    textprintf_centre_ex(buffer, font, SAY_X-1, SAY_Y-1, makecol(1,1,1), -1, "%s", text);
    textprintf_centre_ex(buffer, font, SAY_X+1, SAY_Y+1, makecol(1,1,1), -1, "%s", text);
    textprintf_centre_ex(buffer, font, SAY_X, SAY_Y, makecol(255,255,255), -1, "%s", text);
}

//function to do pending fade in
void game_do_fade_in()
{
    if (game.fadeIn)
    {
        fade_in(gamePalette, FADE_DEFAULT_SPEED);
        game.fadeIn = 0;
    }
}

//function to check if actual room as changed
void check_room_changed()
{
    if (game.actualRoom != game.lastRoom)
    {
        game.lastRoom = game.actualRoom;
        //call new room init
        room[game.actualRoom].room_init();

        //play room song
        //play_midi(room[game.actualRoom].song, -1);

        //set player position on enter room (default or assigned)
        if (game.room_pos_x != 0 && game.room_pos_y != 0)
        {
            player.x = itofix(game.room_pos_x);
            player.y = itofix(game.room_pos_y);
        }
        else
        {
            player.x = itofix(room[game.actualRoom].start_pos_x);
            player.y = itofix(room[game.actualRoom].start_pos_y);
        }
    }
}

//function that handles game exit
void game_exit()
{
    //free resources
    unload_datafile(dataFile);
    //quit allegro modules
    allegro_exit();
}

//function to initialize cursor
void cursor_init()
{
    //clear cursor flags
    cursor.enabled = false;
    cursor.click = false;
    cursor.dblClick = false;
    cursor.rightClick = false;
    cursor.memClick = false;
    cursor.memRightClick = false;
    //clear verb flags
    strcpy(cursor.objectName,"");
    cursor.selectedVerb = GO;
    //move cursor to screen center
    position_mouse(RES_X>>1, RES_Y>>1);
}

//funcion to init the debug vars
void debug_init()
{
    debugVars.numVars = 0;
}

//draws the pointer cursor
void cursor_draw()
{
    if (cursor.enabled)
        draw_sprite(buffer, cursor.image, mouse_x - (cursor.image->w>>1), mouse_y - (cursor.image->h>>1));
}

//function that handles rise clicks
void cursor_button_handler()
{
    //handles doble click (fast walk)
    cursor.dblClick = false;
    if (cursor.evalueDblClick)
    {
        if ( (mouse_b & 1) && !cursor.memClick)
        {
            cursor.dblClick = true;
            cursor.memDblClick = true;
        }
        //timeout double click
        if (cursor.dblClickTimer >= DBL_CLICK_MAX_TIME)
        {
            cursor.evalueDblClick = false;
            cursor.dblClickTimer = 0;
        }
        else
            cursor.dblClickTimer += gameTick;
    }

    //handles rigth button click
    cursor.click = false;
    if ((mouse_b & 1) && !cursor.memClick && !cursor.dblClick)
    {
        cursor.click = true;
        cursor.memClick = true;
        //if verb is GO, evaluate doble click for fast walk
        cursor.evalueDblClick = cursor.selectedVerb == GO;
    }
    if (!(mouse_b & 1))
    {
        cursor.memClick = false;
        cursor.memDblClick = false;
    }
    
    //handles left button click
    cursor.rightClick = 0;
    if ((mouse_b & 2) && !cursor.memRightClick)
    {
        cursor.rightClick = true;
        cursor.memRightClick = true;
    }
    if (!(mouse_b & 2))
        cursor.memRightClick = false;
}

//updates function for cursor. Do call for click handler and check cursor actions
void cursor_update()
{

    //call buttons handler
    cursor_button_handler();

    //check cursor behaviour
    uint8_t hsColor;

    if (cursor.enabled)
    {
        switch (game.state)
        {
            case PLAYING_STATE:
                //if cursor on room position, check color of room hotspot
                if (mouse_y < STATUS_BAR_Y)
                {
                    //obtains the hotspot room color
                    hsColor = getpixel(room[game.actualRoom].hsImage, mouse_x, mouse_y);
                    //gets the object name
                    room[game.actualRoom].room_get_object(hsColor, cursor.objectName);

                    //check left click action on room
                    if (cursor.rightClick)
                    {
                        //if valid object, get default object verb
                        if (cursor.objectName[0] != '\0')
                            cursor.selectedVerb = room[game.actualRoom].room_get_default_object_verb(hsColor);
                        else
                            //otherwise, select go verb
                            cursor.selectedVerb = GO;
                    }
                    
                    //if cursor click on valid object or double click with GO verb or rightClick (default verb assigned)
                    if ((cursor.click || cursor.dblClick || cursor.rightClick) && (cursor.objectName[0] != '\0' || cursor.selectedVerb == GO))
                    {
                        //if no previous action/object selected
                        if (!roomScript.active)
                        {
                            //saves the room vars to start script sequence
                            roomScript.active = 1;
                            roomScript.object = hsColor;
                            roomScript.verb = cursor.selectedVerb;
                        }
                    }

                }
                //if cursor on HUD position, check color of HUD
                else
                {
                    //obtains the hotspot HUD color
                    hsColor = getpixel(hud.hsImage, mouse_x, mouse_y - HUD_Y);

                    //if mouse click and action is valid
                    if (hsColor > 0 && hsColor <= NUM_VERBS && mouse_b & 1)
                    {
                        cursor.selectedVerb = hsColor - 1;
                    }

                    //if mouse left on hud: default verb
                    if (cursor.rightClick)
                    {
                        cursor.selectedVerb = GO;
                    }
                }
                //debug
                show_debug("Color", hsColor);
                break;
        }
    }
}

//draws debug info
void debug_draw()
{
    //writes all the debug vars
    for (int i = 0; i < debugVars.numVars; i++)
    {
        textprintf_ex(buffer, font, 0, DEBUG_Y + (DEBUG_FONT_HEIGHT*i), makecol(255,255,255), -1, "%s: %i", debugVars.varName[i], debugVars.var[i]);
    }
    //reset debug vars
    debugVars.numVars = 0;
}

//draws the status bar
void status_bar_draw()
{

    textprintf_centre_ex(buffer, font, STATUS_BAR_X, STATUS_BAR_Y, makecol(255,255,255), -1, "%s %s", verbName[cursor.selectedVerb], cursor.objectName);
}

//function to init msg structure
void msg_init()
{
    //clear msg and vars
    strcpy(msg.msg, "");
    msg.msgTime = 0;
    msg.msgFinished = false;
    msg.msgActive = false;
}


//function to update message
void msg_update()
{
    //if msg finished, reset the flags
    if (msg.msgFinished)
    {
        msg.msgActive = false;
        msg.msgFinished = false;
        player.talking = false;
    }

    //if msg active, calculate the relation of string length/characters per second
    //and manage the msg time and finished flag
    if (msg.msgActive)
    {
        //disables cursor
        cursor.enabled = false;
        
        int msgLength = strlen(msg.msg);

        if (msgLength > 0)
        {
            int msgDuration = (msgLength / gameConfig.textSpeed);
            //1 second duration minimum
            if (msgDuration == 0)
                msgDuration = 1;

            //convert to 100ms base
            msgDuration *= 10;

            //show_debug("msgLength", msgLength);
            //show_debug("msgDuration", msgDuration);

            if (msg.msgTime >= msgDuration || cursor.click)
            {
                msg.msgFinished = true;
            }
            else
                msg.msgTime += gameTick > 0;

            //set talking flag
            player.talking = true;
        }
    }
    else
    {
        //if not active, reset time and clear msg string
        msg.msgTime = 0;
        strcpy(msg.msg,"");
        //enable cursor
        cursor.enabled = true;
    }
}

//funcion to draw message
void msg_draw()
{
    //don't draw the text if fade in on progress
    if (!game.fadeIn)
    {
        game_write(msg.msg);
    }
}

//function to abort program with critical error
void abort_on_error(const char *msg)
{
    //exit to return text mode
    //allegro_exit();
    //printf(msg);
    #ifndef DEBUGMODE
    allegro_message(msg);
    #else
    allegro_message(msg);
    allegro_message(allegro_error);
    #endif
    exit(EXIT_FAILURE);
}

//updates the room action structure
void room_action_update()
{
    //if nothing selected
    if (!roomScript.active)
    {
        //reset sequence vars
        roomScript.step = 0;
        roomScript.lastStep = 0;
        roomScript.stepTime = 0;
    }
    else
    {
        //sequence timer
        if (gameTick)
        {
          roomScript.stepTime++;
        }
        //reset step timer on step change
        if (roomScript.step != roomScript.lastStep)
        {
            roomScript.stepTime = 0;
            roomScript.lastStep = roomScript.step;
        }

        if (!roomScript.scriptAssigned)
        {
            default_verb_action(roomScript.verb);
            end_script();
        }
    }
}

//draws the actual room to buffer
void room_draw()
{
    blit(room[game.actualRoom].image, buffer, 0, 0, 0, 0, room[game.actualRoom].image->w, room[game.actualRoom].image->h);
}

//draws the actual room front layer to buffer
void room_front_draw()
{
    masked_blit(room[game.actualRoom].fImage, buffer, 0, 0, 0, 0, room[game.actualRoom].fImage->w, room[game.actualRoom].fImage->h);
}

//draws the hud to buffer
void hud_draw()
{
    //draws main image
    blit(hud.image, buffer, 0, 0, 0, HUD_Y, hud.image->w, hud.image->h);
    //blits highlight selected verb (using image because haven't smaller font)
    draw_sprite(buffer, hud.verbSelImage[cursor.selectedVerb],hud.posXVerbSelImage[cursor.selectedVerb], HUD_Y + hud.posYVerbSelImage[cursor.selectedVerb]);
}

//function to init the tick timer
void tick_init()
{
    tick = 0;
    LOCK_VARIABLE(tick);
    LOCK_FUNCTION(incTick);
    install_int(incTick, 100);  //100ms
}

//check 1seg tick
void tick_update()
{
    //reset global timer tick
    gameTick = false;

    if (tick) //100ms tick
    {
        //sets global game tick var
        gameTick = true;
        //reset timer interrupt var
        tick = 0;
    }
}

void mytrace(char *s, ...)
{
    TRACE(s);
}

END_OF_MAIN()
